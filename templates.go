package main

// generated from templates/gobco_*.go

const (
	gobco_fixed_go         = "// This is the fixed part of the gobco code that is injected into the\n// package being checked.\n//\n// Alternatively this code could be provided as a separate go package.\n// This would require that this package were installed at run time,\n// which is a needless restriction.\n\npackage main\n\nimport (\n\t\"bufio\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"os\"\n)\n\ntype gobcoOptions struct {\n\tfirstTime   bool\n\timmediately bool\n\tlistAll     bool\n}\n\ntype gobcoStats struct {\n\tconds []gobcoCond\n}\n\nfunc (st *gobcoStats) filename() string {\n\tfilename := os.Getenv(\"GOBCO_STATS\")\n\tif filename == \"\" {\n\t\tpanic(\"gobco: GOBCO_STATS environment variable must be set\")\n\t}\n\treturn filename\n}\n\nfunc (st *gobcoStats) check(err error) {\n\tif err != nil {\n\t\tpanic(err)\n\t}\n}\n\nfunc (st *gobcoStats) load(filename string) {\n\tfile, err := os.Open(filename)\n\tif err != nil && os.IsNotExist(err) {\n\t\treturn\n\t}\n\n\tdefer func() {\n\t\tcloseErr := file.Close()\n\t\tst.check(closeErr)\n\t}()\n\n\tvar data []gobcoCond\n\tdecoder := json.NewDecoder(bufio.NewReader(file))\n\tdecoder.DisallowUnknownFields()\n\terr = decoder.Decode(&data)\n\tst.check(err)\n\n\tif len(st.conds) != len(data) {\n\t\tmsg := fmt.Sprintf(\n\t\t\t\"gobco: stats file %q must have exactly %d coverage counters\",\n\t\t\tfilename, len(st.conds))\n\t\tpanic(msg)\n\t}\n\tst.conds = data\n}\n\nfunc (st *gobcoStats) merge(other *gobcoStats) {\n\ttype key struct {\n\t\tstart string\n\t\tcode  string\n\t}\n\n\tm := make(map[key]*gobcoCond)\n\tfor i, cond := range st.conds {\n\t\tm[key{cond.Start, cond.Code}] = &st.conds[i]\n\t}\n\n\tfor i := range other.conds {\n\t\tdatum := &other.conds[i]\n\t\tcond := m[key{datum.Start, datum.Code}]\n\t\tdatum.TrueCount += cond.TrueCount\n\t\tdatum.FalseCount += cond.FalseCount\n\t}\n}\n\nfunc (st *gobcoStats) persist(filename string) {\n\tfile, err := os.Create(filename)\n\tst.check(err)\n\n\tdefer func() { st.check(file.Close()) }()\n\n\tbuf := bufio.NewWriter(file)\n\tdefer func() { st.check(buf.Flush()) }()\n\n\tencoder := json.NewEncoder(buf)\n\tencoder.SetIndent(\"\", \"\\t\")\n\tencoder.SetEscapeHTML(false)\n\tencoder.Encode(st.conds)\n}\n\nfunc (st *gobcoStats) cover(idx int, cond bool) bool {\n\tcounts := &st.conds[idx]\n\tif cond {\n\t\tif gobcoOpts.firstTime && counts.TrueCount == 0 {\n\t\t\tfmt.Fprintf(os.Stderr, \"%s: condition %q is true for the first time.\\n\", counts.Start, counts.Code)\n\t\t}\n\t\tcounts.TrueCount++\n\t} else {\n\t\tif gobcoOpts.firstTime && counts.FalseCount == 0 {\n\t\t\tfmt.Fprintf(os.Stderr, \"%s: condition %q is false for the first time.\\n\", counts.Start, counts.Code)\n\t\t}\n\t\tcounts.FalseCount++\n\t}\n\n\tif gobcoOpts.immediately {\n\t\tst.persist(st.filename())\n\t}\n\n\treturn cond\n}\n\nfunc (st *gobcoStats) finish(exitCode int) int {\n\tst.persist(st.filename())\n\treturn exitCode\n}\n\ntype gobcoCond struct {\n\tStart      string\n\tCode       string\n\tTrueCount  int\n\tFalseCount int\n}\n\n// gobcoCover is a separate function to keep the code generation small and simple.\n// It's probably easy to adjust the code generation in instrumenter.wrap.\nfunc gobcoCover(idx int, cond bool) bool {\n\treturn gobcoCounts.cover(idx, cond)\n}\n"
	gobco_fixed_test_go    = "// This is the fixed part of the gobco code that is injected into the\n// package being checked.\n\npackage main\n\nimport \"testing\"\n\n// gobcoTestingM provides a hook to run callbacks before or after the\n// actual testing.M.Run is called.\n//\n// This seemed the easiest way to hook into an arbitrary go program\n// for persisting the coverage data just before exiting.\ntype gobcoTestingM struct {\n\tm *testing.M\n}\n\nfunc (m gobcoTestingM) Run() int {\n\tfilename := gobcoCounts.filename()\n\tgobcoCounts.load(filename)\n\tdefer gobcoCounts.persist(filename)\n\n\treturn m.m.Run()\n}\n"
	gobco_variable_go      = "// This is the variable part of the gobco code that is injected into the\n// package being checked.\n//\n// It is kept as minimal and maintainable as possible.\n//\n// It serves as a template to be used in instrumenter.writeGobcoGo.\n\npackage main\n\nvar gobcoOpts = gobcoOptions{\n\tfirstTime:   true,\n\timmediately: true,\n\tlistAll:     true,\n}\n\nvar gobcoCounts = gobcoStats{\n\tconds: []gobcoCond{},\n}\n"
	gobco_variable_test_go = "package main\n\n// This is the variable part of the gobco code that is injected into the\n// test of the package being checked.\n//\n// It is kept as minimal and maintainable as possible.\n//\n// It serves as a template to be used in instrumenter.writeGobcoTestGo.\n\nimport (\n\t\"os\"\n\t\"testing\"\n)\n\n// TestMain is a demonstration of how gobco may rewrite the code in order\n// to persist the coverage data just before exiting.\n//\n// The original parameter (most probably called m) is renamed to gobcoM,\n// and the original parameter is then introduced as a wrapper around the\n// original m.\n//\n// Since testing.M only provides a single method Run that is expected to be\n// called a single time, this should be enough for most real-world programs.\nfunc TestMain(gobcoM *testing.M) {\n\tm := gobcoTestingM{gobcoM}\n\tos.Exit(m.Run())\n}\n"
)
