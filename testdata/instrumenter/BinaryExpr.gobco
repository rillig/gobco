package instrumenter

// https://go.dev/ref/spec#Index_expressions
// https://go.dev/ref/spec#Arithmetic_operators
// https://go.dev/ref/spec#Comparison_operators
// https://go.dev/ref/spec#Logical_operators

// TODO: Add systematic tests.

// binaryExpr covers the instrumentation of [ast.BinaryExpr], which has the
// expression fields X and Y.
func binaryExpr(i int, a bool, b bool, c bool) {
	// Comparison expressions have return type boolean and are
	// therefore instrumented.
	_ = GobcoCover(0, i > 0)
	pos := GobcoCover(1, i > 0)

	// Expressions consisting of a single identifier do not look like boolean
	// expressions, therefore they are not instrumented.
	_ = pos

	// Binary boolean operators are clearly identifiable and are
	// therefore wrapped.
	//
	// Copying boolean variables is not wrapped though since there
	// is no code branch involved.
	//
	// Also, gobco only looks at the parse tree without any type resolution.
	// Therefore it cannot decide whether a variable is boolean or not.
	both := GobcoCover(2, a && b)
	either := GobcoCover(3, a || b)
	_, _ = both, either

	// When a long chain of '&&' or '||' is parsed, it is split into
	// the rightmost operand and the rest, instrumenting both these
	// parts.
	_ = GobcoCover(4, i == 11 ||
		i == 12 ||
		i == 13 ||
		i == 14 ||
		i == 15)

	_ = GobcoCover(5, i != 21 &&
		i != 22 &&
		i != 23 &&
		i != 24 &&
		i != 25)

	// The operators '&&' and '||' can be mixed as well.
	_ = GobcoCover(6, i == 31 ||
		i >= 32 && i <= 33 ||
		i >= 34 && i <= 35)

	m := map[bool]int{}
	_ = GobcoCover(7, m[GobcoCover(8, i == 41)] == m[GobcoCover(9, i == 42)])

	// In complex conditions, only instrument the terminal conditions
	// 'a', 'b' and 'c', but not the intermediate conditions,
	// to avoid large and redundant conditions in the output.
	f := func(args ...bool) {}
	f(GobcoCover(10, a && b))
	f(GobcoCover(11, a && b && c))
	f(GobcoCover(12, !a))
	f(GobcoCover(13, !a && !b && !c))

	// Instrument deeply nested conditions in if statements.
	mi := map[bool]int{}
	if GobcoCover(14, i == mi[GobcoCover(15, i > 51)]) {
		_ = GobcoCover(16, i == mi[GobcoCover(17, i > 52)])
	}
	for GobcoCover(18, i == mi[GobcoCover(19, i > 61)]) {
		_ = GobcoCover(20, i == mi[GobcoCover(21, i > 62)])
	}
}

// :15:6: "i > 0"
// :16:9: "i > 0"
// :30:10: "a && b"
// :31:12: "a || b"
// :37:6: "i == 11 ||\n\ti == 12 ||\n\ti == 13 ||\n\ti == 14 ||\n\ti == 15"
// :42:6: "i != 21 &&\n\ti != 22 &&\n\ti != 23 &&\n\ti != 24 &&\n\ti != 25"
// :49:6: "i == 31 ||\n\ti >= 32 && i <= 33 ||\n\ti >= 34 && i <= 35"
// :54:6: "m[i == 41] == m[i == 42]"
// :54:8: "i == 41"
// :54:22: "i == 42"
// :60:4: "a && b"
// :61:4: "a && b && c"
// :62:4: "!a"
// :63:4: "!a && !b && !c"
// :67:5: "i == mi[i > 51]"
// :67:13: "i > 51"
// :68:7: "i == mi[i > 52]"
// :68:15: "i > 52"
// :70:6: "i == mi[i > 61]"
// :70:14: "i > 61"
// :71:7: "i == mi[i > 62]"
// :71:15: "i > 62"
