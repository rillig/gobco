package instrumenter

import "fmt"

// https://go.dev/ref/spec#If_statements

// ifStmt covers the instrumentation of [ast.IfStmt], which has the expression
// field Cond.
//
// In condition coverage mode, the terminal conditions from the Cond field of
// an if statement are instrumented.
//
// In branch coverage mode, the main condition is instrumented.
func ifStmt(i int, s string, cond bool) string {

	if GobcoCover(0, i > 0 && s == "positive") == true {
		return "yes, positive"
	}

	if GobcoCover(1, len(s) > 5) == true {
		if GobcoCover(2, len(s) > 10) == true {
			return "long string"
		} else {
			return "medium string"
		}
	}

	// The condition from an if statement is always a boolean expression.
	// And even if the condition is a simple variable, it is wrapped.
	// This is different from arguments to function calls, where simple
	// variables are not wrapped.
	if GobcoCover(3, cond == true) == true {
		return "cond is true"
	}

	// An if statement, like a switch statement, can have an initializer
	// statement. Other than in a switch statement, the condition in an if
	// statement is used exactly once, in the same place as before the
	// instrumentation, so there is no need to introduce a new
	// variable. Therefore, no complicated rewriting is needed.

	if i++; GobcoCover(4, cond == true) == true {
		return fmt.Sprint("incremented ", i > 5)
	}

	if i := i + 1; GobcoCover(5, cond == true) == true {
		return fmt.Sprint("added 1, now ", i > 6)
	}

	// Conditions in the initializer are instrumented as well,
	// but only in condition coverage mode.
	if cond := i > 7; GobcoCover(6, cond == true) == true {
		return fmt.Sprint("condition in initializer ", i > 8)
	}

	if GobcoCover(7, i < 21) == true {
		i += 31
	} else if GobcoCover(8, i < 22) == true {
		i += 32
	} else {
		i += 33
	}

	return "other"
}

// :16:5: "i > 0 && s == \"positive\""
// :20:5: "len(s) > 5"
// :21:6: "len(s) > 10"
// :32:5: "cond"
// :42:10: "cond"
// :46:17: "cond"
// :52:20: "cond"
// :56:5: "i < 21"
// :58:12: "i < 22"
